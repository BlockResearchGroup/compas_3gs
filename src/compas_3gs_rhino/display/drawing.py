from __future__ import absolute_importfrom __future__ import print_functionfrom __future__ import divisionimport compasimport compas_rhinofrom compas.geometry import add_vectorsfrom compas.geometry import dot_vectorsfrom compas.geometry import scale_vectorfrom compas.geometry import subtract_vectorsfrom compas.geometry import normalize_vectorfrom compas.geometry import midpoint_point_pointfrom compas.utilities import i_to_rgbfrom compas.utilities import i_to_greenfrom compas.utilities import color_to_colordictfrom compas_rhino.utilities import xdraw_linesfrom compas_rhino.utilities import xdraw_labelsfrom compas_rhino.utilities import xdraw_cylindersfrom compas_rhino.utilities import delete_objectsimport compas_3gs_rhinofrom compas_3gs.algorithms import volmesh_udfrom compas_3gs.utilities import pair_hf_to_uvfrom compas_3gs.utilities import pair_uv_to_hffrom compas_3gs_rhino.display.helpers import get_index_colordictfrom compas_3gs_rhino.display.helpers import valuedict_to_colordictfrom compas_3gs_rhino.display.helpers import get_force_magsfrom compas_3gs_rhino.display.helpers import get_force_colors_uvfrom compas_3gs_rhino.display.helpers import get_force_colors_hftry:    import rhinoscriptsyntax as rs    import scriptcontext as scexcept ImportError:    compas.raise_if_ironpython()from Rhino.Geometry import Point3dfrom Rhino.Geometry import Arcfrom Rhino.Geometry import ArcCurvefrom Rhino.Geometry import Spherefrom Rhino.Geometry import Vector3dfrom Rhino.Geometry import Planefrom Rhino.Geometry import Brepfind_object = sc.doc.Objects.Findfind_layer_by_fullpath = sc.doc.Layers.FindByFullPathadd_arc = sc.doc.Objects.AddArcadd_brep     = sc.doc.Objects.AddBrep__author__     = ['Juney Lee']__copyright__  = 'Copyright 2018, BLOCK Research Group - ETH Zurich'__license__    = 'MIT License'__email__      = 'juney.lee@arch.ethz.ch'__all__ = [    'draw_cell',    'draw_cell_force_vectors',    'draw_cell_labels',    'clear_cell_labels',    'draw_network_loads',    'draw_directed_uv_and_hf',    'draw_volmesh_face_normals',    'draw_volmesh_UD',    'draw_egi_arcs',    'bake_cells_as_polysurfaces']# ******************************************************************************# ******************************************************************************# ******************************************************************************##   cells## ******************************************************************************# ******************************************************************************# ******************************************************************************def draw_cell(volmesh, ckeys=None):    """Draw the specified cells of a volmesh.    Parameters    ----------    ckeys: list, optional        The keys of specific cells that should be drawn.    """    if not ckeys:        return    hfkeys = []    for ckey in ckeys:        hfkeys += volmesh.cell_halffaces(ckey)    volmesh.draw_faces(keys=hfkeys)def draw_cell_force_vectors(volmesh, ckeys):    """Draw the force vectors of a single cell.    """    center = volmesh.cell_centroid(ckey)    lines  = []    for hfkey in volmesh.halfface:        normal = volmesh.halfface_normal(hfkey, unitized=False)        lines.append({            'start': center,            'end'  : add_vectors(center, normal),            'arrow': 'end',            'color': (0, 255, 0),            'name' : 'hfkey.{}'.format(hfkey)})    compas_rhino.xdraw_lines(lines)def draw_cell_labels(volmesh, text=None, color=None):    """Draw cell labels.    Parameters    ----------    text : dict        A dictionary of ckey-text pairs.        The default value is ``None``, in which case every cell will be labelled with its key.    colors : str, tuple, dict        The color specififcation for the cells.    """    # 1. get ckeys to label ----------------------------------------------------    if text is None:        textdict = {ckey: str(ckey) for ckey in volmesh.cell}    elif isinstance(text, dict):        textdict = text    else:        raise NotImplementedError    # 2. get colors ------------------------------------------------------------    colordict = get_index_colordict(volmesh.cell)    if color:        colordict = color_to_colordict(color,                                       textdict.keys(),                                       default=(0, 0, 0),                                       colorformat='rgb',                                       normalize=False)    # 3. labels ----------------------------------------------------------------    labels = []    for ckey in textdict:        labels.append({            'pos'  : volmesh.cell_center(ckey),            'name' : '{0}.cell.label.{1}'.format(volmesh.name, ckey),            'color': colordict[ckey],            'text' : textdict[ckey]})    # 4. draw ------------------------------------------------------------------    compas_rhino.xdraw_labels(labels,                              layer=volmesh.layer,                              clear=False,                              redraw=False)def clear_cell_labels(volmesh, keys=None):    """Clear cell labels.    Parameters    ----------    keys : list, optional        The keys of a specific set of cell labels that should be cleared.        Default is to clear all cell labels.    """    if not keys:        name = '{}.cell.label.*'.format(volmesh.name)        guids = compas_rhino.get_objects(name=name)    else:        guids = []        for key in keys:            name = '*.cell.label.{}'.format(key)            guid = compas_rhino.get_object(name=name)            guids.append(guid)    compas_rhino.delete_objects(guids)# ******************************************************************************# ******************************************************************************# ******************************************************************************##   volmesh## ******************************************************************************# ******************************************************************************# ******************************************************************************def draw_volmesh_vertex_normals():    passdef draw_volmesh_face_normals(volmesh,                              hfkeys=None,                              hf_c_dict={},                              scale=1):    """Draws the face normals of the volmesh.    Parameters    ----------    volmesh : volmesh object        A volmesh datastructure representing a polyhedral force diagram.    hfkeys : list, optional        Specific hfkeys to display the normals for.    hf_c_dict : dictionary, optional        An optinoal dictionary of hfkey-color pairs.    scale : float, optional        Scale factor for the face normal vectors.    Note    ----        By default, normals of volmesh.faces() are drawn. For the interior cell-to-cell interfaces, the normal will be drawn for only one of the two halffaces at that interface.    """    # 1. evaluate hfkeys -------------------------------------------------------    if not hfkeys:        hfkeys = volmesh.faces()    # 2. normals to draw -------------------------------------------------------    f_normals = []    for hfkey in hfkeys:        center = volmesh.halfface_center(hfkey)        normal = scale_vector(volmesh.halfface_normal(hfkey), scale)        name   = '{}.edge.f_normal.{}'.format(volmesh.attributes['name'], hfkey)        color  = (0, 255, 0)        if hfkey in hf_c_dict:            color = hf_c_dict[hfkey]        f_normals.append({            'start': center,            'end'  : add_vectors(center, normal),            'arrow': 'end',            'color': color,            'name' : name})    # 3. draw ------------------------------------------------------------------    compas_rhino.xdraw_lines(f_normals,                             layer=volmesh.layer,                             clear=False,                             redraw=False)def draw_volmesh_UD(volmesh,                    network,                    color_cells=False,                    draw_prisms=True,                    scale=0.5):    """    """    # 10. check ----------------------------------------------------------------    # 1. colors ----------------------------------------------------------------    face_color = (0, 0, 0)    prism_c = (155, 225, 255)  # color for compression prisms    prism_t = (255, 180, 180)  # color for tension prisms    hf_c_dict = {}    if color_cells:        hf_c_dict = get_force_colors_hf(volmesh, network)    # 2. compute unified diagram geometries ------------------------------------    halffaces, prism_faces = volmesh_ud(volmesh, network, scale=scale)    # 3. draw halffaces and prisms ---------------------------------------------    faces = []    for hfkey in volmesh.halfface:        vkeys = volmesh.halfface[hfkey]        hf_xyz = [halffaces[hfkey][i] for i in vkeys]        name = '{}.face.ud.*'.format(volmesh.name)        if hf_c_dict:            face_color = hf_c_dict[hfkey]        faces.append({'points': hf_xyz,                      'name'  : name,                      'color' : face_color})    if draw_prisms:        forces = get_force_mags(volmesh, network)        for uv in prism_faces:            name = '{}.face.ud.prism.{}'.format(volmesh.name, uv)            color = prism_c            if forces[uv] > 0:                color = prism_t            for face in prism_faces[uv]:                faces.append({'points': face,                              'name'  : name,                              'color' : color})    compas_rhino.xdraw_faces(faces,                             layer=volmesh.layer,                             clear=False,                             redraw=False)# ******************************************************************************# ******************************************************************************# ******************************************************************************##   network## ******************************************************************************# ******************************************************************************# ******************************************************************************def draw_network_loads(volmesh,                       network,                       vkeys=[],                       gradient=True,                       scale=1.0):    """Draws the boundary forces on the form diagram.    Parameters    ----------    volmesh : volmesh object        A volmesh datastructure representing a polyhedral force diagram.    network : network object        A network datastructure representing a polyhedral form diagram.    vkeys : list, optional        List of vertex keys to draw the boundary forces for.    gradient : boolean, optional        Whether to display the boundary forces in a gradient color range. Default is green: (0, 255, 0).    show_value : boolean, optional        Whether to display the magnitude of boundary force as a number.    scale : float, optional        Drawing scale factor for the boundary forces.    """    # 1. delete any existing boundary forces -----------------------------------    name = '*.edge.loads.*'    delete_objects(compas_rhino.get_objects(name=name))    # 2. get boundary hfs ------------------------------------------------------    hfkeys = volmesh.halffaces_on_boundary()    # evaluate specified vertices    if vkeys:        temp_hfs = []        for vkey in vkeys:            cell_hfs = volmesh.cell_halffaces(vkey)            for cell_hf in cell_hfs:                if cell_hf in hfkeys:                    temp_hfs.append(cell_hf)        if not temp_hfs:            return        hfkeys = temp_hfs    # 3. get hf areas and colors -----------------------------------------------    hf_areas  = {hfkey: volmesh.halfface_area(hfkey) for hfkey in hfkeys}    hf_c_dict = valuedict_to_colordict(hf_areas, color_scheme=i_to_green)    # 4. forces and labels to draw ---------------------------------------------    lines = []    for hfkey in hfkeys:        ckey   = volmesh.halfface_cell(hfkey)        normal = volmesh.halfface_normal(hfkey, unitized=False)        area   = hf_areas[hfkey],        vector = scale_vector(normal, scale)        sp     = network.vertex_coordinates(ckey)        ep     = add_vectors(sp, vector)        color  = (0, 255, 0)        if gradient:            color = hf_c_dict[hfkey]        lines.append({            'start': sp,            'end'  : ep,            'color': color,            'arrow': 'end',            'name' : '{}.edge.loads.{}.{}'.format(network.name, hfkey, area)})    # 5. draw ------------------------------------------------------------------    volmesh.draw_edges()    volmesh.draw_faces(keys=hfkeys, color=hf_c_dict)    compas_rhino.xdraw_lines(lines,                             layer=network.layer,                             clear=False,                             redraw=False)def draw_network_pipes(volmesh,                       network,                       colordict=None,                       scale=1.0):    default_color = (0, 0, 0)    # 1. get colordict ---------------------------------------------------------    if not colordict:        colordict = {uv: default_color for uv in network.edges()}    # 2. map uv to hf ----------------------------------------------------------    uv_hf_dict = pair_uv_to_hf(volmesh, network)    # 3. pipes to draw ---------------------------------------------------------    cylinders = []    for uv in network.edges():        cylinders.append({            'start' : network.vertex_coordinates(uv[0]),            'end'   : network.vertex_coordinates(uv[1]),            'radius': volmesh.halfface_area(uv_hf_dict[uv]) * scale,            'color' : colordict[uv],            'layer' : network.layer,            'name'  : '{}.edge.pipes.{}'.format(network.name, uv)})    # 4. draw ------------------------------------------------------------------    compas_rhino.xdraw_cylinders(cylinders, cap=True)def draw_network_vertex_forces(volmesh,                               network,                               vkeys=[],                               gradient=False,                               scale=1.0):    pass# ******************************************************************************# ******************************************************************************# ******************************************************************************##   both diagrams## ******************************************************************************# ******************************************************************************# ******************************************************************************def draw_directed_uv_and_hf(volmesh,                            network,                            color_id=False,                            label=False):    # 1. get colors ------------------------------------------------------------    uv_c_dict = {uv: (0, 0, 0) for uv in network.edges()}    hf_c_dict = get_force_colors_hf(volmesh, network, uv_c_dict=uv_c_dict)    if color_id:        uv_c_dict  = get_index_colordict(list(network.edges()))        hf_c_dict  = get_force_colors_hf(volmesh, network, uv_c_dict=uv_c_dict)    # 2. edges to draw ---------------------------------------------------------    edges = []    for u, v in network.edges():        u_hfkey, v_hfkey = volmesh.cell_pair_hfkeys(u, v)        edges.append({            'start': network.vertex_coordinates(u),            'end'  : network.vertex_coordinates(v),            'arrow': 'end',            'color': uv_c_dict[(u, v)],            'name' : '{}.edge.{}-{}'.format(network.name, u, v)})    # 3. draw network ----------------------------------------------------------    network.clear()    compas_rhino.xdraw_lines(edges,                             layer=network.layer,                             clear=False,                             redraw=False)    # 4. draw volmesh ----------------------------------------------------------    hfkeys = hf_c_dict.keys()    volmesh.clear()    volmesh.draw_edges()    volmesh.draw_faces(keys=hfkeys, color=hf_c_dict)    draw_volmesh_face_normals(volmesh, hfkeys, hf_c_dict=hf_c_dict, scale=2)    # draw labels --------------------------------------------------------------    if label:        text_dict = {fkey: str(fkey) for fkey in hfkeys}        volmesh.draw_face_labels(text=text_dict, color=hf_c_dict)        network.draw_edge_labels(color=uv_c_dict)# ******************************************************************************# ******************************************************************************# ******************************************************************************##   other## ******************************************************************************# ******************************************************************************# ******************************************************************************def draw_egi_arcs(egi):    origin = egi.attributes['origin']    rs.AddPoint(Point3d(*origin))    rs.AddLayer('egi_arcs')    for u, v in egi.edges():        normal_1 = subtract_vectors(egi.vertex_coordinates(u), origin)        normal_2 = subtract_vectors(egi.vertex_coordinates(v), origin)        name = str(egi.edge_name(u, v))        _draw_arc(normal_1, normal_2, origin, layer='egi_arcs', name=name)def _draw_arc(normal_1, normal_2, origin, layer=None, name=None):    mid_pt = normalize_vector(add_vectors(normal_1, normal_2))    arc    = Arc(Point3d(*[sum(axis) for axis in zip(normal_1, origin)]),                 Point3d(*[sum(axis) for axis in zip(mid_pt, origin)]),                 Point3d(*[sum(axis) for axis in zip(normal_2, origin)]))    arc_as_curve = ArcCurve(arc)    return arc_as_curvedef bake_cells_as_polysurfaces(volmesh):    for ckey in volmesh.cell:        origin = volmesh.cell_centroid(ckey)        ball   = Sphere(Point3d(*tuple(origin)), 100)        brep   = Brep.CreateFromSphere(ball)        rs.EnableRedraw(False)        for hfkey in volmesh.cell_halffaces(ckey):            center = volmesh.halfface_center(hfkey)            normal = volmesh.halfface_normal(hfkey)            plane  = Plane(Point3d(*tuple(center)), Vector3d(*tuple(normal)))            intersection = brep.Trim(plane, 0.1)            if intersection:                brep = brep.Trim(plane, 0.001)[0]                brep = brep.CapPlanarHoles(0.001)        guid  = add_brep(brep)        obj   = find_object(guid)        attr  = obj.Attributes        layer = 'cells_as_polysurfaces'        rs.AddLayer(layer)        index = find_layer_by_fullpath(layer, True)        if index >= 0:            attr.LayerIndex = index        attr.Name = 'cell.{0}'.format(ckey)        obj.CommitChanges()